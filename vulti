#!/bin/bash

# Vulti - A "second brain" for your terminal commands and system setup.
# Version: 0.1.0

VERSION="0.1.0"
VULTI_DIR="$HOME/.vulti"
BACKUP_DIR="$VULTI_DIR/backups"
DB_FILE="$VULTI_DIR/commands.db"

# Colors
NC='\033[0m' # No Color
RED='\033[0;31m'
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'

# --- Helper Functions ---

log() { echo -e "${GREEN}[Vulti]${NC} $1"; }
warn() { echo -e "${YELLOW}[Warning]${NC} $1"; }
error() { echo -e "${RED}[Error]${NC} $1"; exit 1; }

init() {
    mkdir -p "$VULTI_DIR"
    mkdir -p "$BACKUP_DIR"
    [[ ! -f "$DB_FILE" ]] && touch "$DB_FILE"
}

check_deps() {
    local deps=("zip" "unzip")
    for cmd in "${deps[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            warn "Dependency '$cmd' is missing. Some features may not work."
        fi
    done
}

detect_distro() {
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        DISTRO=$ID
    else
        DISTRO="unknown"
    fi
    
    case "$DISTRO" in
        arch|manjaro|endeavouros)
            PKG_MGR="pacman"
            PKG_SAVE_CMD="pacman -Qqe"
            PKG_INSTALL_CMD="sudo pacman -S --needed --noconfirm"
            ;;
        ubuntu|debian|pop|mint|kali)
            PKG_MGR="apt"
            PKG_SAVE_CMD="apt-mark showmanual"
            PKG_INSTALL_CMD="sudo apt-get install -y"
            ;;
        fedora|rhel|centos)
            PKG_MGR="dnf"
            PKG_SAVE_CMD="dnf repoquery --userinstalled --qf '%{name}'"
            PKG_INSTALL_CMD="sudo dnf install -y"
            ;;
        *)
            PKG_MGR="unknown"
            warn "Unknown distro '$DISTRO'. Package save/restore may not work."
            ;;
    esac
}

confirm() {
    read -p "$1 [y/N]: " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "Aborted."
        exit 0
    fi
}

# --- Commands ---

cmd_help() {
    cat << EOF
Vulti v$VERSION - Your CLI Second Brain

Usage: vulti <command> [options]

Commands:
  add <tag> --cmd '<cmd>'      Save a command with a tag.
  list                         List all saved commands.
  run <tag> [opts]             Run a saved command.
                               Options: --sudo, --bg (background)
  rm <tag>                     Remove a saved command.
  view                         View/Edit Vulti files or backups.
  save                         Capture current system state (packages, configs).
  backup                       Create a full backup zip of Vulti data.
  restore [--from <file>]      Restore from a backup.
  reset                        Wipe all Vulti data and start fresh.
  --help, -h                   Show this help message.
  --version                    Show version.

Examples:
  vulti add obs --cmd 'sudo pacman -S obs-studio'
  vulti run obs
  vulti view
  vulti backup
EOF
}

cmd_add() {
    local tag="$1"
    shift
    local cmd=""
    
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --cmd) cmd="$2"; shift ;;
            *) error "Unknown parameter: $1" ;;
        esac
        shift
    done

    [[ -z "$tag" ]] && error "Tag required."
    [[ -z "$cmd" ]] && error "Command required (use --cmd '<cmd>')."
    
    # Validate tag (alphanumeric only)
    if [[ ! "$tag" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        error "Invalid tag. Use alphanumeric characters, underscores, or hyphens."
    fi

    # Check if exists
    if grep -q "^$tag|" "$DB_FILE"; then
        warn "Tag '$tag' already exists."
        confirm "Overwrite?"
        sed -i "/^$tag|/d" "$DB_FILE"
    fi

    echo "$tag|$cmd" >> "$DB_FILE"
    log "Saved '$tag'."
}

cmd_list() {
    if [[ ! -s "$DB_FILE" ]]; then
        log "No commands saved."
        return
    fi
    
    echo -e "${BLUE}TAG             COMMAND${NC}"
    echo "----------------------------------------"
    # Use column for formatting if available, else simple cat
    if command -v column &> /dev/null; then
        column -t -s '|' "$DB_FILE"
    else
        cat "$DB_FILE"
    fi
}

cmd_run() {
    local tag=""
    local use_sudo=false
    local run_bg=false

    # Parse args
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --sudo) use_sudo=true ;;
            --bg) run_bg=true ;;
            -*) error "Unknown option: $1" ;;
            *) 
                if [[ -z "$tag" ]]; then
                    tag="$1"
                else
                    error "Unknown argument: $1"
                fi
                ;;
        esac
        shift
    done

    [[ -z "$tag" ]] && error "Tag required."

    local line=$(grep "^$tag|" "$DB_FILE")
    [[ -z "$line" ]] && error "Tag '$tag' not found."

    local cmd=${line#*|}
    
    # Apply options
    if [[ "$use_sudo" == "true" ]]; then
        cmd="sudo $cmd"
    fi
    
    if [[ "$run_bg" == "true" ]]; then
        cmd="($cmd) &"
    fi

    echo -e "Command: ${YELLOW}$cmd${NC}"
    
    # Warn if sudo is in the command string but --sudo wasn't used (just for info)
    if [[ "$cmd" == *"sudo"* ]] && [[ "$use_sudo" == "false" ]]; then
        warn "This command contains 'sudo'."
    fi
    
    confirm "Execute?"
    eval "$cmd"
}

cmd_rm() {
    local tag="$1"
    [[ -z "$tag" ]] && error "Tag required."

    if ! grep -q "^$tag|" "$DB_FILE"; then
        error "Tag '$tag' not found."
    fi

    confirm "Delete '$tag'?"
    sed -i "/^$tag|/d" "$DB_FILE"
    log "Deleted '$tag'."
}

cmd_view() {
    echo "Select a file to view/edit:"
    echo "1) Commands Database ($DB_FILE)"
    echo "2) Package List ($VULTI_DIR/packages.txt)"
    echo "3) Flatpak List ($VULTI_DIR/flatpaks.txt)"
    echo "4) Latest Backup"
    echo "5) Cancel"
    
    read -p "Choice [1-5]: " choice
    
    local file=""
    case $choice in
        1) file="$DB_FILE" ;;
        2) file="$VULTI_DIR/packages.txt" ;;
        3) file="$VULTI_DIR/flatpaks.txt" ;;
        4) 
            file=$(ls -t "$BACKUP_DIR"/*.zip 2>/dev/null | head -n1)
            [[ -z "$file" ]] && error "No backups found."
            log "Viewing contents of $file"
            unzip -l "$file" | less
            return
            ;;
        *) return ;;
    esac

    if [[ ! -f "$file" ]]; then
        error "File $file does not exist. Run 'vulti save' first?"
    fi

    echo "Select editor:"
    echo "1) nano"
    echo "2) nvim"
    echo "3) code (VS Code)"
    echo "4) cat (View only)"
    
    read -p "Choice [1-4]: " ed_choice
    
    case $ed_choice in
        1) nano "$file" ;;
        2) nvim "$file" ;;
        3) code "$file" ;;
        4) cat "$file" ;;
        *) log "Invalid choice." ;;
    esac
}

cmd_save() {
    log "Saving system state..."
    
    # Package Manager
    if [[ "$PKG_MGR" != "unknown" ]] && command -v "$PKG_MGR" &> /dev/null; then
        log "Detected $PKG_MGR. Saving packages..."
        eval "$PKG_SAVE_CMD" > "$VULTI_DIR/packages.txt"
        log "Saved packages to packages.txt"
    else
        warn "Package manager not detected or not supported. Skipping package list."
    fi

    # Flatpak
    if command -v flatpak &> /dev/null; then
        flatpak list --app --columns=application > "$VULTI_DIR/flatpaks.txt"
        log "Saved flatpaks to flatpaks.txt"
    fi

    # Configs
    if [[ -d "$HOME/.config" ]]; then
        local config_zip="$VULTI_DIR/configs.zip"
        log "Zipping ~/.config/ (this might take a moment)..."
        
        # Zip exit codes:
        # 0: Normal
        # 1: Warnings (e.g., file not found) - Acceptable
        # 18: File open error (e.g., locked files) - Acceptable for backup
        
        zip -r -y -q "$config_zip" "$HOME/.config" -x "*.cache*" "*.git*" "*/node_modules/*" "*/.venv/*" 2>/dev/null
        local ret=$?
        
        if [[ $ret -eq 0 || $ret -eq 1 || $ret -eq 18 ]]; then
            log "Saved configs to configs.zip (Exit code: $ret)"
        else
            warn "Failed to zip configs (Exit code: $ret). Check permissions."
        fi
    fi
}

cmd_backup() {
    local timestamp=$(date +%Y-%m-%d)
    local backup_file="vulti-backup-$timestamp.zip"
    
    # Make sure we have latest state
    cmd_save
    
    log "Creating backup archive..."
    # Zip the vulti directory contents
    cd "$VULTI_DIR" || exit
    if zip -r -q "$BACKUP_DIR/$backup_file" . -x "backups/*"; then
        log "Backup created at $BACKUP_DIR/$backup_file"
    else
        error "Backup failed."
    fi
}

cmd_restore() {
    local backup_file=""
    local dry_run=false
    
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --from) backup_file="$2"; shift ;;
            --dry-run) dry_run=true ;;
            *) ;;
        esac
        shift
    done

    if [[ -z "$backup_file" ]]; then
        # Find latest in backups dir
        backup_file=$(ls -t "$BACKUP_DIR"/*.zip 2>/dev/null | head -n1)
        [[ -z "$backup_file" ]] && error "No backup file found in $BACKUP_DIR."
    fi

    log "Restoring from $backup_file..."
    if [[ "$dry_run" == "true" ]]; then
        log "[DRY RUN] Would unzip $backup_file to $VULTI_DIR"
        log "[DRY RUN] Would install packages using: $PKG_INSTALL_CMD"
        log "[DRY RUN] Would restore configs from configs.zip"
        return
    fi

    confirm "This will overwrite current Vulti data and attempt to install packages. Continue?"

    # Unzip to temp dir first
    local tmp_dir=$(mktemp -d)
    unzip -q "$backup_file" -d "$tmp_dir"
    
    # Restore DB
    if [[ -f "$tmp_dir/commands.db" ]]; then
        cp "$tmp_dir/commands.db" "$DB_FILE"
        log "Restored commands database."
    fi

    # Install Packages
    if [[ -f "$tmp_dir/packages.txt" ]] && [[ "$PKG_MGR" != "unknown" ]]; then
        log "Installing packages using $PKG_MGR..."
        # Read packages, filter out comments/empty lines
        local pkgs=$(grep -vE "^\s*#" "$tmp_dir/packages.txt" | tr '\n' ' ')
        if [[ -n "$pkgs" ]]; then
             # Construct install command
             local install_cmd="$PKG_INSTALL_CMD $pkgs"
             eval "$install_cmd"
        else
             log "No packages found in packages.txt"
        fi
    else
        warn "Skipping package installation (unknown manager or missing file)."
    fi

    # Install Flatpaks
    if [[ -f "$tmp_dir/flatpaks.txt" ]] && command -v flatpak &> /dev/null; then
        log "Installing Flatpaks..."
        local fps=$(grep -vE "^\s*#" "$tmp_dir/flatpaks.txt" | tr '\n' ' ')
        if [[ -n "$fps" ]]; then
            flatpak install -y $fps
        fi
    fi

    # Restore Configs
    if [[ -f "$tmp_dir/configs.zip" ]]; then
        log "Restoring configs to ~/.config/..."
        confirm "Overwrite existing configs in ~/.config/?"
        unzip -o -q "$tmp_dir/configs.zip" -d "$HOME/"
    fi
    
    rm -rf "$tmp_dir"
    log "Restore complete."
}

cmd_reset() {
    warn "This will DELETE ALL Vulti data, including saved commands and backups."
    confirm "Are you sure you want to reset Vulti?"
    rm -rf "$VULTI_DIR"
    log "Vulti has been reset. Run 'vulti' to re-initialize."
}

# --- Main ---

init
check_deps
detect_distro

case "$1" in
    add) shift; cmd_add "$@" ;;
    list) cmd_list ;;
    run) shift; cmd_run "$@" ;; # Pass all args to run for flag parsing
    rm) cmd_rm "$2" ;;
    view) cmd_view ;;
    save) cmd_save ;;
    backup) cmd_backup ;;
    restore) shift; cmd_restore "$@" ;;
    reset) cmd_reset ;;
    --help|-h) cmd_help ;;
    --version) echo "Vulti v$VERSION" ;;
    *) 
        # Check if it's a shorthand for run
        if [[ -n "$1" ]] && grep -q "^$1|" "$DB_FILE"; then
            cmd_run "$@"
        else
            cmd_help
            exit 1
        fi
        ;;
esac
